### Thread
- Light Weight Process
- 프로세스 내에서 생성되는 흐름의 단위
- 일반적으로 한 프로세스에 한 스레드이지만 프로그램 환경에 따라 두 개 이상의 스레드 실행이 가능

#### 특징
- 프로세스와 달리 별도의 통신 기법(IPC 등) 없이 스레드간 자원 공유 가능
- 각 스레드에는 각기 실행이 가능한 stack이 존재(code, data, heap 영역은 공유하면서 별도의 stack을 실행)
- 소프트웨어 병행 작업처리 가능(멀티 스레드)

#### 장점
- CPU 활용도, 성능 증가
- 응답성 향상

#### 단점
- 하나의 스레드 문제가, 프로세스 전반에 영향을 미침
- 여러 스레드 생성시 성능 저하 가능성 존재(Context Swicthing이 빈번하게 일어나..)

#### 동기화(Synchronization) 이슈
- 동기화: 작업들 사이에 실행 시기를 맞추는 것
- 여러 스레드가 동일한 자원(데이터)에 접근 시 동기화 이슈 발생
  - 동일 자원을 여러 스레드가 동시 수정시, 각 스레드 결과에 영향을 줌

- 해결방안
  - Mutual exclusion(상호 배제)
  - 여러 스레드가 변경하는(접근 가능한) 자원에 대해 Exclusive Access 필요(자원이 수정되고 있을 때 다른 스레드의 접근을 막는다)

#### Mutex와 Semaphore
- 임계구역에 대한 접근을 막기 위한 Locking 매커니즘
- Mutex(binary semaphore)
  - 임계구역에 하나의 스레드만 들어갈 수 있음
- Semaphore
  - 임계구역에 여러 스레드가 들어갈 수 있음
  - counter를 두어 동시에 리소스에 접근 할 수 있는 허용 가능한 스레드 수를 제어
```
P(S): wait(S) {
    while S <= 0; //대기
    S--; // 다른 프로세스 접근 제한
}
```
```
V(S): signal(S) {
    S++; // 다른 프로세스 접근 허용
}
```
- V : 세마포어 값
- P : 검사 (임계영역 들어갈 때)
- V : 증가 (임계영역에서 나올 때)
- loop는 무중단으로 부하 걸림(바쁜대기) -> 대기 큐로 보완
```
wait(S) {
    S -> count--;
    if (S -> count <= 0) {
        add thiss process to S -> queue;
        block()
    }
}
```